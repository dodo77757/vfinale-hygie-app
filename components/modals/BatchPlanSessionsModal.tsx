import React, { useState } from 'react';
import { UserProfile, RecurrencePattern } from '../../types';
import { StorageService } from '../../services/storageService';
import { notificationService } from '../../services/notificationService';
import { CalendarValidationService } from '../../services/calendarValidationService';

interface BatchPlanSessionsModalProps {
  isOpen: boolean;
  onClose: () => void;
  clients: UserProfile[];
  onUpdate: (updatedClients: UserProfile[]) => void;
}

export const BatchPlanSessionsModal: React.FC<BatchPlanSessionsModalProps> = ({
  isOpen,
  onClose,
  clients,
  onUpdate
}) => {
  const [selectedClientIds, setSelectedClientIds] = useState<Set<string>>(new Set());
  const [startDate, setStartDate] = useState(new Date().toISOString().split('T')[0]);
  const [endDate, setEndDate] = useState('');
  const [recurrenceType, setRecurrenceType] = useState<'none' | 'weekly' | 'custom'>('none');
  const [daysOfWeek, setDaysOfWeek] = useState<number[]>([]);
  const [notes, setNotes] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);

  if (!isOpen) return null;

  const weekDays = [
    { value: 1, label: 'Lundi' },
    { value: 2, label: 'Mardi' },
    { value: 3, label: 'Mercredi' },
    { value: 4, label: 'Jeudi' },
    { value: 5, label: 'Vendredi' },
    { value: 6, label: 'Samedi' },
    { value: 0, label: 'Dimanche' }
  ];

  const toggleDay = (day: number) => {
    const newDays = daysOfWeek.includes(day)
      ? daysOfWeek.filter(d => d !== day)
      : [...daysOfWeek, day];
    setDaysOfWeek(newDays);
  };

  const handleSubmit = async () => {
    if (selectedClientIds.size === 0) {
      notificationService.warning('Veuillez sélectionner au moins un client');
      return;
    }

    if (!startDate) {
      notificationService.warning('Veuillez sélectionner une date de début');
      return;
    }

    if (recurrenceType === 'weekly' && daysOfWeek.length === 0) {
      notificationService.warning('Veuillez sélectionner au moins un jour de la semaine');
      return;
    }

    setIsProcessing(true);
    try {
      let allClients = [...clients];
      const selectedClients = clients.filter(c => selectedClientIds.has(c.id));
      let totalSessions = 0;

      let skippedSessions = 0;
      selectedClients.forEach(client => {
        const sessions: any[] = [];
        const start = new Date(startDate);
        // 24 semaines par défaut (168 jours)
        const defaultEndDate = new Date(start.getTime() + 24 * 7 * 24 * 60 * 60 * 1000);
        const end = endDate ? new Date(endDate) : defaultEndDate;

        if (recurrenceType === 'none') {
          // Vérifier si on peut planifier cette session
          const validation = CalendarValidationService.canPlanSessionOnDate(client, start);
          if (validation.canPlan) {
            sessions.push({
              id: `planned_${Date.now()}_${client.id}`,
              date: start.toISOString(),
              clientId: client.id,
              notes: notes.trim() || undefined,
              isAutoGenerated: false
            });
          } else {
            skippedSessions++;
            // Essayer de trouver la prochaine date disponible
            const nextDate = CalendarValidationService.findNextAvailableDate(client, start, 30);
            if (nextDate) {
              sessions.push({
                id: `planned_${Date.now()}_${client.id}`,
                date: nextDate.toISOString(),
                clientId: client.id,
                notes: notes.trim() || undefined,
                isAutoGenerated: false
              });
            }
          }
        } else if (recurrenceType === 'weekly') {
          // Sessions récurrentes selon les jours sélectionnés
          const currentDate = new Date(start);
          while (currentDate <= end) {
            const dayOfWeek = currentDate.getDay();
            if (daysOfWeek.includes(dayOfWeek)) {
              // Utiliser le service de validation
              const validation = CalendarValidationService.canPlanSessionOnDate(client, currentDate);
              if (validation.canPlan) {
                sessions.push({
                  id: `planned_${Date.now()}_${client.id}_${currentDate.getTime()}`,
                  date: new Date(currentDate).toISOString(),
                  clientId: client.id,
                  notes: notes.trim() || undefined,
                  isAutoGenerated: false
                });
              } else {
                skippedSessions++;
              }
            }
            currentDate.setDate(currentDate.getDate() + 1);
          }
        }

        if (sessions.length > 0) {
          totalSessions += sessions.length;
          const updatedClient: UserProfile = {
            ...client,
            plannedSessions: [...(client.plannedSessions || []), ...sessions]
          };
          allClients = StorageService.updateClient(updatedClient);
        }
      });

      StorageService.saveClients(allClients);
      onUpdate(allClients);
      
      let message = `${totalSessions} session(s) planifiée(s) pour ${selectedClients.length} client(s)`;
      if (skippedSessions > 0) {
        message += ` (${skippedSessions} session(s) ignorée(s) - conflit avec session existante)`;
      }
      if (!endDate) {
        message += ' - Durée: 24 semaines';
      }
      
      notificationService.success(message);
      onClose();
      
      // Reset
      setSelectedClientIds(new Set());
      setStartDate(new Date().toISOString().split('T')[0]);
      setEndDate('');
      setRecurrenceType('none');
      setDaysOfWeek([]);
      setNotes('');
    } catch (error) {
      notificationService.error('Erreur lors de la planification');
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="fixed inset-0 z-[1000] bg-[#181818]/80 flex items-center justify-center p-4 backdrop-blur-md" onClick={onClose}>
      <div
        className="bg-white border border-[#007c89]/20 rounded-lg w-full max-w-2xl max-h-[90vh] overflow-y-auto shadow-xl"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between border-b border-[#007c89]/20 p-4 sticky top-0 bg-white z-10">
          <h2 className="font-bebas text-xl text-[#181818]">Planification en Masse</h2>
          <button
            onClick={onClose}
            className="text-[#6B7280] hover:text-[#181818] text-xl"
          >
            ✕
          </button>
        </div>

        <div className="p-6 space-y-6">
          {/* Sélection des clients */}
          <div>
            <label className="block text-sm font-semibold text-[#181818] mb-3">
              Clients ({selectedClientIds.size} sélectionné{selectedClientIds.size > 1 ? 's' : ''})
            </label>
            <div className="max-h-48 overflow-y-auto border border-[#007c89]/30 rounded-md p-3 custom-scrollbar space-y-2">
              {clients.map(client => (
                <label
                  key={client.id}
                  className="flex items-center gap-2 p-2 hover:bg-[#f3efe5] rounded cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={selectedClientIds.has(client.id)}
                    onChange={(e) => {
                      const newSet = new Set(selectedClientIds);
                      if (e.target.checked) {
                        newSet.add(client.id);
                      } else {
                        newSet.delete(client.id);
                      }
                      setSelectedClientIds(newSet);
                    }}
                    className="text-[#007c89]"
                  />
                  <span className="text-sm text-[#181818]">{client.nom}</span>
                </label>
              ))}
            </div>
          </div>

          {/* Dates */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-semibold text-[#181818] mb-2">
                Date de début
              </label>
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="w-full bg-white border border-[#007c89]/30 rounded-md px-4 py-2 text-sm text-[#181818] focus:border-[#007c89] focus:outline-none focus:ring-2 focus:ring-[#007c89]/20"
              />
            </div>
            <div>
              <label className="block text-sm font-semibold text-[#181818] mb-2">
                Date de fin (optionnel)
                <span className="text-xs text-[#6B7280] font-normal ml-2">Par défaut: 24 semaines</span>
              </label>
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                className="w-full bg-white border border-[#007c89]/30 rounded-md px-4 py-2 text-sm text-[#181818] focus:border-[#007c89] focus:outline-none focus:ring-2 focus:ring-[#007c89]/20"
                placeholder="24 semaines par défaut"
              />
            </div>
          </div>

          {/* Information */}
          <div className="p-3 bg-[#e0f4f6] rounded-md border border-[#007c89]/20">
            <p className="text-xs text-[#007c89] font-semibold mb-1">ℹ️ Règles de planification</p>
            <ul className="text-[10px] text-[#6B7280] space-y-1 list-disc list-inside">
              <li>Une seule session par jour maximum par client</li>
              <li>Durée par défaut : 24 semaines si non spécifiée</li>
              <li>Les conflits sont automatiquement évités</li>
            </ul>
          </div>

          {/* Récurrence */}
          <div>
            <label className="block text-sm font-semibold text-[#181818] mb-3">
              Récurrence
            </label>
            <div className="space-y-3">
              <label className="flex items-center gap-2">
                <input
                  type="radio"
                  checked={recurrenceType === 'none'}
                  onChange={() => {
                    setRecurrenceType('none');
                    setDaysOfWeek([]);
                  }}
                  className="text-[#007c89]"
                />
                <span className="text-sm text-[#181818]">Une seule session</span>
              </label>
              <label className="flex items-center gap-2">
                <input
                  type="radio"
                  checked={recurrenceType === 'weekly'}
                  onChange={() => setRecurrenceType('weekly')}
                  className="text-[#007c89]"
                />
                <span className="text-sm text-[#181818]">Hebdomadaire</span>
              </label>
            </div>

            {recurrenceType === 'weekly' && (
              <div className="mt-4 p-4 bg-[#f3efe5] rounded-md border border-[#007c89]/20">
                <label className="block text-xs font-semibold text-[#181818] mb-2">
                  Jours de la semaine
                </label>
                <div className="grid grid-cols-2 gap-2">
                  {weekDays.map(day => (
                    <label
                      key={day.value}
                      className={`flex items-center gap-2 p-2 rounded cursor-pointer transition-all ${
                        daysOfWeek.includes(day.value)
                          ? 'bg-[#007c89] text-white'
                          : 'bg-white text-[#181818] border border-[#007c89]/30 hover:bg-[#007c89]/10'
                      }`}
                    >
                      <input
                        type="checkbox"
                        checked={daysOfWeek.includes(day.value)}
                        onChange={() => toggleDay(day.value)}
                        className="text-[#007c89]"
                      />
                      <span className="text-sm font-semibold">{day.label}</span>
                    </label>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Notes */}
          <div>
            <label className="block text-sm font-semibold text-[#181818] mb-2">
              Notes (optionnel)
            </label>
            <textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="Notes pour ces sessions..."
              rows={3}
              className="w-full bg-white border border-[#007c89]/30 rounded-md px-4 py-2 text-sm text-[#181818] placeholder:text-[#6B7280] focus:border-[#007c89] focus:outline-none focus:ring-2 focus:ring-[#007c89]/20 resize-none"
            />
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-4 border-t border-[#007c89]/20">
            <button
              onClick={handleSubmit}
              disabled={isProcessing}
              className="flex-1 px-4 py-2 bg-[#007c89] text-white rounded-md text-sm font-semibold hover:bg-[#006a75] transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isProcessing ? 'Planification...' : 'Planifier'}
            </button>
            <button
              onClick={onClose}
              className="px-4 py-2 bg-white text-[#181818] border border-[#007c89]/30 rounded-md text-sm font-semibold hover:bg-[#f3efe5] transition-all"
            >
              Annuler
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

